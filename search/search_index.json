{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Welcome","text":"<p>Hey, this is an index!</p>"},{"location":"blog/SLOs/","title":"SLIs, SLOs, and SLAs","text":"<p>Source Attribution</p> <p>The core concepts and examples in this document are extracted from Dark Mode Club's video. It is highly recommended to watch the full explanation:</p> <p> Watch: Dark Mode Club - SLIs, SLOs, SLAs</p>"},{"location":"blog/SLOs/#1-planning","title":"1. Planning","text":"<p>Service Level Objectives (SLOs) distinguish themselves from standard <code>alerting</code> and <code>monitoring</code> by focusing strictly on operations that matter to the user.</p>"},{"location":"blog/SLOs/#the-planning-workflow","title":"The Planning Workflow","text":"Step Description Example 1. Operation A customer-facing operation important enough to warrant an SLO. A new order is generated, submitted, and acknowledged. 2. SLI (Indicator) The measurable data needed from the system to compute the SLOs. Latency in seconds from \"order submitted\" to \"order acknowledged\" (derived from logs/telemetry). 3. Aggregation Window A timeframe meaningful to the business to spot trends/hotspots. 8 hours. 4. Target Reliability The percentage of success required. (Prod usually &gt; 99%). 90% (for this example). 5. SLO (Objective) The combination of the Indicator and the Target. New orders are acknowledged within 1 second and achieve this level of service 90% of the time."},{"location":"blog/SLOs/#categories-of-slis","title":"Categories of SLIs","text":"<p>Based on \"Database Reliability Engineering\" by Laine Campbell &amp; Charity Majors.</p> LatencyAvailabilityConsistencyThroughput <p>Measurement of delay in a communication flow.</p> <p>Usually measured in units of time. Best practice is to measure boundaries:</p> <ul> <li>Upper bound: \"Created within 2 seconds.\"</li> <li>Range: \"Created between 1 and 2 seconds.\"</li> </ul> <p>Is the service functional?</p> <p>A simple measurement of whether or not a service is generally available given a valid request.</p> <ul> <li>Example: HTTP 200 OK vs HTTP 500 Error.</li> </ul> <p>Quality of Data.</p> <p>\"Do users receive the data they expected?\"</p> <p>The Caching Trap</p> <p>Techniques like caching improve Latency, but overdoing it might negatively impact Consistency (data freshness).</p> <p>Hybrid Example (Consistency + Latency):</p> <p>\"Users see an online check deposit reflected in their transaction history within 2 seconds.\"</p> <p>Quantity of data sent/received within a timeframe.</p> <ul> <li>Example: \"Transactions processed per second: <code>3</code>\".</li> </ul> <p>Context matters: An overnight batch process measures throughput very differently from a real-time streaming service.</p>"},{"location":"blog/SLOs/#2-implementing","title":"2. Implementing","text":"<p>Implementation is the delivery phase where SLOs impact development efforts.</p> <ol> <li>Basics: Ensure SLIs identified in planning are present in logs or time-series DBs.</li> <li>Architecture Impact:<ul> <li>Targeting 99%? Likely no major architectural changes.</li> <li>Targeting 99.999%? Profound impact on infra and design.</li> </ul> </li> </ol> <p>Start Small</p> <p>Don't refactor your entire architecture on day one.</p> <p>Goal 1: Get actual reliability under measurement.</p> <p>Goal 2: Iteratively add SLIs to code and hook them into tools like Prometheus.</p>"},{"location":"blog/SLOs/#code-instrumentation-example","title":"Code Instrumentation Example","text":"<p>Scenario: User clicks \"checkout\".</p> <p>SLI: Seconds to process a valid order (derived from logs).</p> <p>We need 3 distinct log events:</p> <ol> <li>Request initiation.</li> <li>Success with latency calculation.</li> <li>Failure events.</li> </ol> OrderService.scala<pre><code>@throws(classOf[ValidationException])\ndef checkout(cartItems: ShoppingCart,\n             creditCardFrom: CreditCardFrom,\n             shippingAdressFrom: AddressFrom): Order = {\n\n  logger.info(\"checkout requested\") // (1)\n\n  try {\n    startTime = timer.start() // (2)\n    validCard = validateCreditCard(creditCardForm)\n    validAddress = validateShippingAdress(shippingAddressFrom)\n    order = processOrder(validCard, validAddress, cartItems))\n    endTime = timer.end()\n    elapsedTime = endTime - startTime\n\n    // Log success with specific latency\n    logger.info(s\"order ${order.id} successfully took ${elapsedTime}ms\") // (3)\n    return order\n  }\n  catch (e: ValidationException) {\n    // Log known validation errors (client side errors)\n    logger.info(\"checkout request failed due to a validation error\") // (4)\n    throw e\n  }\n  catch (e: ServiceException) {\n    // Log server side errors\n    logger.error(\"checkout request failed\") // (5)\n    throw e\n  }\n}\n</code></pre> <ol> <li>Total Requests Marker: Essential for the denominator in our formula.</li> <li>Timer: Capture high-precision timestamps.</li> <li>Success Marker: Capture the successful ID and the <code>elapsedTime</code>.</li> <li>Client Error: These often shouldn't count against your reliability score (depending on policy).</li> <li>Server Error: These definitely count against reliability.</li> </ol>"},{"location":"blog/SLOs/#3-operations","title":"3. Operations","text":"<p>Once SLIs are implemented, we need visualization (Dashboards) and Reporting.</p>"},{"location":"blog/SLOs/#the-tooling-stack","title":"The Tooling Stack","text":"<ul> <li> Sloth: Generates Prometheus rules from simple SLO spec files. Saves time vs. hand-coding rules.</li> <li> Prometheus: Standard for metrics-based SLIs.</li> <li> Grafana: Visualizing the data (Supports Prometheus &amp; Loki).</li> <li> Loki: Like Prometheus, but for logs. Great for legacy apps where you can't change code easily but have logs.</li> <li> Thanos: Solves Prometheus retention limits (Unlimited history).</li> <li> NOBL9: Turn-key platform for SLOs (if you want to buy vs build).</li> </ul>"},{"location":"blog/SLOs/#workflow-logging-to-dashboard-loki-path","title":"Workflow: Logging to Dashboard (Loki path)","text":"<ol> <li>Promtail: Configure to scrape specific log files containing SLI data.</li> <li>Extraction: Define parser configs (Regex/JSON) in Promtail to isolate fields (latency, status).</li> <li>Loki: Query language extracts the metrics.</li> <li>Grafana: Visualize the query over the Aggregation Window.</li> </ol>"},{"location":"blog/SLOs/#4-the-maths","title":"4. The Maths","text":"<p>How to calculate the final percentage.</p>"},{"location":"blog/SLOs/#scenario-a-standard-calculation","title":"Scenario A: Standard Calculation","text":"<p>Objective: New orders acknowledged within 1s.</p> <p>Total Requests: 110 | Validation Errors: 10 | Service Errors: 10 | Slow Requests: 2</p> \\[ SLO = \\frac{Successful Requests}{Total Requests} \\] <p>Breakdown:</p> <ul> <li>Valid Requests = (Total - Validation Errors) = \\(110 - 10 = 100\\)</li> <li>Failures = (Service Errors + Slow Requests) = \\(10 + 2 = 12\\)</li> <li>Successes = (Valid Requests - Failures) = \\(100 - 12 = 88\\)</li> </ul> \\[ SLO = \\frac{88}{100} = 88\\% \\] <p>Result</p> <p>88% &lt; 90% Target. We missed the SLO.</p>"},{"location":"blog/SLOs/#scenario-b-filtering-service-errors","title":"Scenario B: Filtering \"Service Errors\"","text":"<p>Sometimes, we only want to measure Latency performance, excluding crashes (which might be covered by an Availability SLO).</p> <p>Formula adjustment: Remove Service Errors from the denominator.</p> \\[ SLO = \\frac{88}{(100 - 10)} = \\frac{88}{90} = 97\\% \\] <p>Result</p> <p>97% &gt; 90% Target. We passed the Latency SLO.</p>"},{"location":"blog/SLOs/#5-understanding-error-budgets","title":"5. Understanding &amp; Error Budgets","text":"<p>This phase involves periodically reviewing reliability (monthly/quarterly). Data-driven decisions beat gut feelings.</p>"},{"location":"blog/SLOs/#the-burn-rate","title":"The Burn Rate","text":"<p>If you target 90% but achieve 99.9%, you have a surplus of reliability. This is your Error Budget.</p> <ul> <li>Under Budget (Failing): Freeze features, focus on reliability.</li> <li>Over Budget (Success): Spend the budget on risky changes, refactoring, or speed.</li> </ul> Advanced: Calculating Error Budget <p>Example for a 99.9% Availability Target:</p> Text Only<pre><code>Error Budget = 1 - Availability SLO\nError Budget = 1 - 99.9% = 0.1%\n\nTime Calculation (Monthly):\n0.1% of 30 days = 43.2 minutes\n</code></pre> <p>Note: Don't worry about this when starting out. Get the measurements working first.</p>"},{"location":"blog/SLOs/#resources","title":"Resources","text":"<p>Books</p> <ul> <li> Implementing Service Level Objectives - Alex Hidalgo</li> <li> Database Reliability Engineering - Laine Campbell &amp; Charity Majors</li> <li> Google's SRE Book List</li> </ul> <p>Tools</p> <ul> <li> Sloth (Prometheus SLO Generator)</li> <li> Prometheus</li> <li> Grafana &amp; Loki</li> <li> Thanos (HA Prometheus)</li> <li> Nobl9</li> </ul> <p>Articles &amp; Lectures</p> <ul> <li>Setting SLOs with Custom Metrics (Google Cloud)</li> <li>Google SRE Lecture Series Summary</li> </ul>"},{"location":"books/Site%20Reliability%20Engineering/Chapter%201/","title":"Chapter 1 - Introduction","text":"<p>\"Hope is not a strategy.\" \u2014 Traditional SRE saying</p> <p>This document breaks down the fundamental shift from the traditional \"Sysadmin\" model to Google's Site Reliability Engineering (SRE) model. It outlines the core tenets necessary to run large-scale systems efficiently.</p>"},{"location":"books/Site%20Reliability%20Engineering/Chapter%201/#the-problem-the-sysadmin-approach","title":"The Problem: The Sysadmin Approach","text":"<p>Historically, companies treated \"Development\" and \"Operations\" as discrete, isolated teams. This model suffers from specific pitfalls:</p> <ul> <li>Linear Scaling Costs: As traffic grows, you need more humans to manage events and updates.</li> <li>Misaligned Incentives: Developers want velocity (new features), while Ops want stability (no changes).</li> <li>The \"Trench Warfare\" Effect: Ops creates gatekeeping to slow down changes, while Devs try to bypass gates with \"flag flips\" or incremental updates to sneak features in.</li> </ul> <p>The Cost of Separation</p> <p>The split between Dev and Ops leads to a pathology of communication breakdowns, conflicting goals, and a lack of mutual trust.</p>"},{"location":"books/Site%20Reliability%20Engineering/Chapter%201/#the-solution-the-sre-approach","title":"The Solution: The SRE Approach","text":"<p>Google's definition is simple: \"SRE is what happens when you ask a software engineer to design an operations team.\"</p>"},{"location":"books/Site%20Reliability%20Engineering/Chapter%201/#team-composition","title":"Team Composition","text":"<p>The SRE team is a synthesis of different skill sets, typically split into two buckets:</p> <ol> <li>50\u201360% Google Software Engineers: Hired via standard SWE procedures.</li> <li>40\u201350% System Experts: Candidates with 85\u201399% of SWE skills but with rare technical expertise, specifically UNIX system internals and Layer 1\u20133 networking.</li> </ol>"},{"location":"books/Site%20Reliability%20Engineering/Chapter%201/#the-scaling-advantage","title":"The Scaling Advantage","text":"<p>Unlike the sysadmin model, SRE is designed to scale sublinearly.</p> <ul> <li>SREs are bored by manual tasks and have the skillset to automate them.</li> <li>The goal is to create systems that are automatic, not just automated.</li> <li>The team repairs itself; as the service grows, SREs focus on engineering solutions rather than adding more bodies to the rotation.</li> </ul>"},{"location":"books/Site%20Reliability%20Engineering/Chapter%201/#the-50-rule","title":"The 50% Rule","text":"<p>To prevent the team from drowning in operational load (toil), Google enforces a strict cap on \"ops\" work.</p> <p>Code or Drown</p> <p>The team tasked with managing a service needs to code or it will drown.</p> <ul> <li>The Cap: SREs spend a maximum of 50% of their time on ops (tickets, on-call, manual tasks).</li> <li>The Remaining 50%: Must be spent on actual development and engineering projects to make the service stable and operable.</li> <li>Enforcement: If ops load exceeds 50%, the burden is shifted back to the Development team, or staff is added specifically to handle the load without assigning them extra ops duties.</li> </ul>"},{"location":"books/Site%20Reliability%20Engineering/Chapter%201/#devops-vs-sre","title":"DevOps vs. SRE","text":"<p>Think of it in object-oriented terms: class SRE implements DevOps.</p> <ul> <li>DevOps: A general philosophy involving heavy automation and cross-functional cooperation.</li> <li>SRE: A specific implementation of DevOps with idiosyncratic extensions (like error budgets).</li> </ul>"},{"location":"books/Site%20Reliability%20Engineering/Chapter%201/#the-tenets-of-sre","title":"The Tenets of SRE","text":"<p>While workflows vary, all SRE teams adhere to these core principles to maintain their engineering focus.</p>"},{"location":"books/Site%20Reliability%20Engineering/Chapter%201/#1-durable-focus-on-engineering","title":"1. Durable Focus on Engineering","text":"<p>We monitor the operational load to ensure we have time to code.</p> <ul> <li>On-Call Limit: Maximum of 2 events per 8\u201312 hour shift.</li> <li>Why? More than 2 events prevents thorough investigation and postmortems; fewer than 1 event is a waste of time.</li> <li>Postmortems: Written for all significant incidents (even those that didn't page) to expose faults and apply engineering fixes.</li> </ul>"},{"location":"books/Site%20Reliability%20Engineering/Chapter%201/#2-error-budgets-velocity-vs-stability","title":"2. Error Budgets (Velocity vs. Stability)","text":"<p>We resolve the conflict between Dev and Ops by accepting that 100% availability is the wrong target.</p> \\[ Error Budget = 1 - Availability Target \\] <ul> <li>The Reality: Users cannot distinguish between 100% and 99.999% availability due to the noise of their own ISP, WiFi, or hardware failures.</li> <li>The Strategy: The business defines an availability target (e.g., 99.99%). The remaining 0.01% is the Error Budget.</li> <li>Spending the Budget: This budget can be spent on risky feature launches or experiments.</li> <li>Consequence: If the budget is exhausted, releases stop until the system stabilizes. This aligns Dev and Ops incentives.</li> </ul>"},{"location":"books/Site%20Reliability%20Engineering/Chapter%201/#3-monitoring","title":"3. Monitoring","text":"<p>Monitoring shouldn't require humans to stare at screens. There are only three valid outputs:</p> Type Definition Action Required  Alerts Something is broken or about to break. Immediate human action required.  Tickets Something needs attention, but it can wait a few days. Delayed human action required.  Logging Recorded for forensics/diagnostics. No action unless prompted by an investigation."},{"location":"books/Site%20Reliability%20Engineering/Chapter%201/#4-emergency-response","title":"4. Emergency Response","text":"<p>Reliability is a function of Mean Time to Failure (MTTF) and Mean Time to Repair (MTTR).</p> <ul> <li>Objective: Lower MTTR.</li> <li>Playbooks: Recording best practices in a playbook produces roughly 3x improvement in MTTR compared to \"winging it\".</li> <li>Practice: Use exercises like the \"Wheel of Misfortune\" to prepare engineers.</li> </ul>"},{"location":"books/Site%20Reliability%20Engineering/Chapter%201/#5-change-management","title":"5. Change Management","text":"<ul> <li>Fact: Roughly 70% of outages are due to changes in a live system.</li> <li>Mitigation:<ul> <li>Progressive rollouts.</li> <li>Quick/Accurate problem detection.</li> <li>Safe rollback capabilities.</li> </ul> </li> </ul>"},{"location":"books/Site%20Reliability%20Engineering/Chapter%201/#6-capacity-planning","title":"6. Capacity Planning","text":"<p>We must ensure sufficient capacity for organic (natural adoption) and inorganic (launches/marketing) growth.</p> <p>Mandatory Steps</p> <ol> <li>Forecast: Accurate organic demand forecasting beyond lead times.</li> <li>Inorganic: Incorporation of business-driven events (launches).</li> <li>Load Testing: Regular testing to correlate raw capacity (disk/cpu) to service capacity.</li> </ol>"},{"location":"books/Site%20Reliability%20Engineering/Chapter%201/#7-provisioning","title":"7. Provisioning","text":"<p>Provisioning combines change management and capacity planning. It must be fast, correct, and only done when necessary because capacity is expensive.</p>"},{"location":"books/Site%20Reliability%20Engineering/Chapter%201/#8-efficiency-and-performance","title":"8. Efficiency and Performance","text":"<p>SREs are ultimately responsible for utilization and cost.</p> <ul> <li>The Lever: Provisioning strategy is a massive lever on total service costs.</li> <li>Performance: A slow system eventually stops serving (infinite slowness). Improving performance adds capacity and efficiency.</li> </ul> <p>Next Steps: Check out the Prometheus Documentation to see how modern monitoring implements the Alerting vs. Logging distinction mentioned in Tenet 3.</p>"},{"location":"cheatsheets/grafana_dashboards/","title":"Grafana Dashboards: A Complete Guide","text":"<p>Source Reference</p> <p>Based on: Grafana dashboards: A complete guide</p> <p> Original Author: Alexandre de Verteuil</p> <p> Last Updated: Jan 9, 2023</p>"},{"location":"cheatsheets/grafana_dashboards/#introduction","title":"Introduction","text":"<p>Dashboards are easy to create but difficult to maintain at scale. Without a clear strategy, organizations often face \"dashboard sprawl.\" The following classification scheme helps organize dashboards based on business processes and engineering needs.</p>"},{"location":"cheatsheets/grafana_dashboards/#1-methodologies-use-reds","title":"1. Methodologies: USE &amp; REDS","text":"<p>Foundational dashboards for SREs. These should be visually simple, uniform, and composed primarily of time-series panels.</p>  USE Method REDS Method <p>Hardware / Resource Oriented</p> <p>The USE Method (Utilization, Saturation, Errors) is designed for physical or virtual resources.</p> <ul> <li>Target: Analyzing machine health and identifying root causes of infrastructure performance issues.</li> <li>Key Metrics: CPU, Memory, Disk I/O, Network bandwidth.</li> </ul> <p>Service / User Oriented</p> <p>The REDS metrics (Requests, Errors, Duration, Saturation) derive from the Four Golden Signals.</p> <ul> <li>Target: Microservices and API endpoints.</li> <li>Usage: Primary candidates for alerting; these metrics serve as a proxy for the actual user experience.</li> </ul>"},{"location":"cheatsheets/grafana_dashboards/#2-navigation-flows","title":"2. Navigation &amp; Flows","text":""},{"location":"cheatsheets/grafana_dashboards/#overview-and-drill-down","title":"Overview and Drill Down","text":"<p>Implemented using Dashboard Links or Data Links to create a hierarchy.</p> <ul> <li>Overview: High-level aggregated metrics for the entire infrastructure or fleet.</li> <li>Drill Down: granular metrics focusing on a single component or instance.</li> </ul>"},{"location":"cheatsheets/grafana_dashboards/#business-journey","title":"Business Journey","text":"<p>Visualizations that track high-level business logic rather than technical metrics.</p> <ul> <li>Scope: Customer acquisition funnels, supply chain logistics, or physical operations (e.g., IoT manufacturing lines).</li> </ul>"},{"location":"cheatsheets/grafana_dashboards/#the-home-dashboards","title":"The Home Dashboards","text":"<p>Custom entry points configured at the Organization, Team, or User level.</p> <ul> <li>Strategy: Can range from simple row additions to \"Enterprise\" setups with team-specific layouts.</li> <li>Components: Useful for displaying admin contact info and dynamic Dashboard Lists.</li> </ul>"},{"location":"cheatsheets/grafana_dashboards/#3-development-workflows","title":"3. Development Workflows","text":""},{"location":"cheatsheets/grafana_dashboards/#research-development-rd","title":"Research &amp; Development (R&amp;D)","text":"<p>Sandboxes for iterative dashboard design and \"work-in-progress\" (WIP).</p> <ul> <li>Organization: Isolate in folders like <code>SRE R&amp;D</code> or <code>AIOps Drafts</code>.</li> <li>Best Practice: Avoid using production tags to prevent drafts from polluting global search results.</li> </ul>"},{"location":"cheatsheets/grafana_dashboards/#metrics-exploration","title":"Metrics Exploration","text":"<p>Abstract, reusable dashboards for browsing data when specific metric names are unknown.</p> <p>Design Pattern: Use Variables to select metric prefixes, with panels repeating automatically.</p> <p>PromQL Aggregation Templates:</p> PromQL<pre><code># 1. Average Value\navg without (instance) ($metric)\n\n# 2. Total Sum\nsum without (instance) ($metric)\n\n# 3. Average Per-Second Rates\navg without (instance) (rate($metric[$__rate_interval]))\n\n# 4. Total Rate Sum\nsum without (instance) (rate($metric[$__rate_interval]))\n</code></pre>"},{"location":"cheatsheets/grafana_dashboards/#4-operational-views","title":"4. Operational Views","text":""},{"location":"cheatsheets/grafana_dashboards/#alerts-analysis","title":"Alerts Analysis","text":"<p>Visualizes the history and state of alerts, typically using the State Timeline panel.</p> <p>Visualizing Alert States (State Timeline):</p> <p>Map states to integers for visualization (e.g., 3=Meta, 2=Firing, 1=Pending).</p> PromQL<pre><code>max by (alertname,alertstate) (\n  3 * max_over_time(ALERTS{alertname=\"AlwaysFiring\"}[$__interval])\n  or\n  2 * max_over_time(ALERTS{alertstate=\"firing\"}[$__interval])\n  or\n  max_over_time(ALERTS{alertstate=\"pending\"}[$__interval])\n)\n</code></pre> <p>Counting Firing Alerts (Status History):</p> PromQL<pre><code>count by (alertname) (max_over_time(ALERTS{alertstate=\"firing\"}[$__interval]))\n</code></pre>"},{"location":"cheatsheets/grafana_dashboards/#issue-dashboards","title":"Issue Dashboards","text":"<p>Ephemeral dashboards created for specific incident investigations.</p> <ul> <li>Lifecycle: Temporary; should be archived or deleted after resolution.</li> <li>Naming Convention: Include timestamp or Incident ID (e.g., <code>2023-10-Incident-Database-Lock</code>).</li> </ul>"},{"location":"cheatsheets/grafana_dashboards/#meta-monitoring","title":"Meta-Monitoring","text":"<p>Observability for the observability stack itself ( Prometheus,  Loki,  Alertmanager).</p> <ul> <li>Access: Restricted to Platform Admins.</li> <li>Purpose: Ensure the monitoring pipeline is healthy (e.g., scrape failures, rule evaluation times).</li> </ul>"},{"location":"cheatsheets/grafana_dashboards/#5-visualization-formats","title":"5. Visualization Formats","text":""},{"location":"cheatsheets/grafana_dashboards/#big-screen-wall-tv","title":"Big Screen (Wall TV)","text":"<p>Optimized for open office displays or NOCs.</p> <ul> <li>UX Design: High contrast, large fonts, instant readability (Stat panels, Gauges).</li> <li>Focus: Identifying what is broken immediately, rather than explaining why.</li> </ul>"},{"location":"cheatsheets/grafana_dashboards/#reports","title":"Reports","text":"<p>Requires Grafana Enterprise.</p> <p>Layouts designed for PDF export and email distribution to stakeholders.</p> <ul> <li>Constraints: Must be tuned for static rendering; interactive elements do not translate well to print/PDF.</li> </ul>"},{"location":"cheatsheets/grafana_dashboards/#6-automation-sourcing","title":"6. Automation &amp; Sourcing","text":""},{"location":"cheatsheets/grafana_dashboards/#prebuilt-dashboards","title":"Prebuilt Dashboards","text":"<ul> <li>Sources: Community Plugins, Cloud Integrations, and Mixins (Jsonnet bundles).</li> <li>Repository: Grafana Dashboards Public Repo.</li> </ul>"},{"location":"cheatsheets/grafana_dashboards/#dashboards-as-code-iac","title":"Dashboards as Code (IaC)","text":"<p>Managing dashboards via API or Terraform to ensure version control and reproducibility.</p> <p>Automation Methods:</p> <ul> <li>File Provisioning: Placing JSON files in the server's provisioning directory (CI/CD friendly).</li> <li>HTTP API: Scripted interactions.</li> </ul> <p>API Reference</p> <p>Key endpoints for automation:</p> <ul> <li> Auth API</li> <li> Dashboard API</li> <li> Folder API</li> </ul> <p>Tooling:</p> <ul> <li>Grafonnet (Jsonnet library)</li> <li>Grizzly (Dashboards as Code tool)</li> <li>Terraform Provider</li> </ul>"},{"location":"cheatsheets/grafana_dashboards/#7-organization-strategy","title":"7. Organization Strategy","text":""},{"location":"cheatsheets/grafana_dashboards/#the-watchtower-structure","title":"\"The Watchtower\" Structure","text":"<p>Recommended folder taxonomy for self-hosted instances to maintain order:</p> Folder Purpose Archive Deprecated dashboards (kept for query recovery). Issues Investigation dashboards (Prefix: <code>yyyy-mm-dd</code>). User Prod Personal dashboards promoted to production use. User R&amp;D Personal drafts and experiments. Meta-monitoring Stack health and Metrics Exploration. General Shared, stable production dashboards."},{"location":"cheatsheets/grafana_dashboards/#references","title":"References","text":"<ul> <li> Best practices for managing dashboards</li> <li> Dashboard folders documentation</li> <li> Permissions &amp; Roles</li> </ul>"},{"location":"cheatsheets/logQL/","title":"LogQL Cheat Sheet","text":"<p>Loki Query Language reference for log aggregation and analysis.</p>"},{"location":"cheatsheets/logQL/#query-types","title":"Query Types","text":"Type Returns Example Log queries Log lines <code>{job=\"nginx\"}</code> Metric queries Numeric values <code>rate({job=\"nginx\"}[5m])</code> <p>Key Difference from PromQL</p> <p>LogQL queries start with log stream selectors, then optionally apply filters and metrics.</p>"},{"location":"cheatsheets/logQL/#log-stream-selectors","title":"Log Stream Selectors","text":""},{"location":"cheatsheets/logQL/#basic-selection","title":"Basic Selection","text":"PromQL<pre><code># Single label\n{job=\"nginx\"}\n\n# Multiple labels (AND)\n{job=\"nginx\", env=\"production\"}\n\n# Multiple values (OR - use regex)\n{job=~\"nginx|apache\"}\n</code></pre>"},{"location":"cheatsheets/logQL/#label-matching-operators","title":"Label Matching Operators","text":"EqualityInequalityRegex PromQL<pre><code># Exact match\n{job=\"nginx\"}\n\n# Multiple exact matches\n{job=\"nginx\", namespace=\"default\"}\n</code></pre> PromQL<pre><code># Not equal\n{job!=\"nginx\"}\n\n# Exclude namespace\n{namespace!=\"kube-system\"}\n</code></pre> PromQL<pre><code># Match pattern\n{job=~\"nginx.*\"}\n\n# Match multiple\n{job=~\"nginx|apache\"}\n\n# Negative regex\n{job!~\"test.*\"}\n</code></pre>"},{"location":"cheatsheets/logQL/#log-pipeline","title":"Log Pipeline","text":"<p>Chain operations to filter and parse logs:</p> PromQL<pre><code>{job=\"nginx\"}\n  | json\n  | line_format \"{{.method}} {{.path}}\"\n  | label_format level=`{{ .level | ToUpper }}`\n</code></pre>"},{"location":"cheatsheets/logQL/#line-filters","title":"Line Filters","text":""},{"location":"cheatsheets/logQL/#filter-operators","title":"Filter Operators","text":"ContainsNot ContainsRegex MatchRegex Not Match PromQL<pre><code># Contains text\n{job=\"nginx\"} |= \"error\"\n\n# Contains any of\n{job=\"nginx\"} |= \"error\" |= \"warning\"\n</code></pre> PromQL<pre><code># Does not contain\n{job=\"nginx\"} != \"debug\"\n\n# Exclude multiple\n{job=\"nginx\"} != \"debug\" != \"trace\"\n</code></pre> PromQL<pre><code># Regex match\n{job=\"nginx\"} |~ \"error|warning\"\n\n# Case insensitive\n{job=\"nginx\"} |~ \"(?i)error\"\n</code></pre> PromQL<pre><code># Negative regex\n{job=\"nginx\"} !~ \"debug|trace\"\n</code></pre>"},{"location":"cheatsheets/logQL/#combining-filters","title":"Combining Filters","text":"PromQL<pre><code># Multiple conditions (AND)\n{job=\"nginx\"}\n  |= \"error\"\n  != \"timeout\"\n  |~ \"status=[45]..\"\n</code></pre>"},{"location":"cheatsheets/logQL/#parser-expressions","title":"Parser Expressions","text":""},{"location":"cheatsheets/logQL/#json-parser","title":"JSON Parser","text":"PromQL<pre><code># Parse JSON logs\n{job=\"app\"} | json\n\n# Access nested fields\n{job=\"app\"} | json | status=\"200\"\n\n# Specific fields\n{job=\"app\"} | json level, message, status\n</code></pre>"},{"location":"cheatsheets/logQL/#logfmt-parser","title":"Logfmt Parser","text":"PromQL<pre><code># Parse logfmt (key=value format)\n{job=\"app\"} | logfmt\n\n# Filter on parsed fields\n{job=\"app\"} | logfmt | level=\"error\"\n</code></pre>"},{"location":"cheatsheets/logQL/#pattern-parser","title":"Pattern Parser","text":"PromQL<pre><code># Extract with patterns\n{job=\"nginx\"} | pattern `&lt;ip&gt; - - &lt;_&gt; \"&lt;method&gt; &lt;path&gt; &lt;_&gt;\" &lt;status&gt; &lt;_&gt;`\n\n# Named captures\n{job=\"nginx\"} | pattern `&lt;ip&gt; - - [&lt;timestamp&gt;] \"&lt;method&gt; &lt;path&gt; &lt;protocol&gt;\" &lt;status&gt;`\n</code></pre>"},{"location":"cheatsheets/logQL/#regexp-parser","title":"Regexp Parser","text":"PromQL<pre><code># Named capture groups\n{job=\"nginx\"} \n  | regexp `(?P&lt;ip&gt;\\S+) .* \"(?P&lt;method&gt;\\w+) (?P&lt;path&gt;\\S+).*\" (?P&lt;status&gt;\\d+)`\n\n# Filter on extracted fields\n{job=\"nginx\"} \n  | regexp `status=(?P&lt;status&gt;\\d+)`\n  | status &gt;= 400\n</code></pre>"},{"location":"cheatsheets/logQL/#label-filters","title":"Label Filters","text":"<p>Filter after parsing:</p> PromQL<pre><code># Filter on extracted labels\n{job=\"app\"} | json | level=\"error\"\n\n# Numeric comparison\n{job=\"app\"} | json | status &gt;= 400\n\n# Multiple conditions\n{job=\"app\"} | json | level=\"error\" | status &gt;= 500\n</code></pre>"},{"location":"cheatsheets/logQL/#comparison-operators","title":"Comparison Operators","text":"PromQL<pre><code>==  # Equal\n!=  # Not equal\n&gt;   # Greater than\n&gt;=  # Greater or equal\n&lt;   # Less than\n&lt;=  # Less or equal\n</code></pre>"},{"location":"cheatsheets/logQL/#formatting","title":"Formatting","text":""},{"location":"cheatsheets/logQL/#line_format","title":"line_format","text":"<p>Restructure log lines:</p> PromQL<pre><code># Custom format\n{job=\"nginx\"} \n  | json \n  | line_format \"{{.method}} {{.path}} - {{.status}}\"\n\n# With functions\n{job=\"app\"} \n  | json \n  | line_format \"{{.timestamp | ToUpper}} {{.level}}\"\n</code></pre>"},{"location":"cheatsheets/logQL/#label_format","title":"label_format","text":"<p>Create or modify labels:</p> PromQL<pre><code># Create new label\n{job=\"app\"} \n  | json \n  | label_format status_code=`{{.status}}`\n\n# Transform label\n{job=\"app\"} \n  | json \n  | label_format level=`{{ .level | ToUpper }}`\n</code></pre>"},{"location":"cheatsheets/logQL/#available-functions","title":"Available Functions","text":"PromQL<pre><code>ToLower      # Convert to lowercase\nToUpper      # Convert to uppercase\nReplace      # Replace text\nTrim         # Trim whitespace\nTrimLeft     # Trim left\nTrimRight    # Trim right\nTrimPrefix   # Remove prefix\nTrimSuffix   # Remove suffix\n</code></pre>"},{"location":"cheatsheets/logQL/#metric-queries","title":"Metric Queries","text":""},{"location":"cheatsheets/logQL/#range-vector-aggregation","title":"Range Vector Aggregation","text":"PromQL<pre><code># Count log lines\ncount_over_time({job=\"nginx\"}[5m])\n\n# Rate of log lines per second\nrate({job=\"nginx\"}[5m])\n\n# Bytes processed per second\nbytes_rate({job=\"nginx\"}[5m])\n\n# Bytes processed in time range\nbytes_over_time({job=\"nginx\"}[5m])\n</code></pre>"},{"location":"cheatsheets/logQL/#functions","title":"Functions","text":"Function Description Example <code>rate()</code> Per-second rate <code>rate({job=\"nginx\"}[5m])</code> <code>count_over_time()</code> Count of entries <code>count_over_time({job=\"nginx\"}[5m])</code> <code>bytes_rate()</code> Bytes per second <code>bytes_rate({job=\"nginx\"}[5m])</code> <code>bytes_over_time()</code> Total bytes <code>bytes_over_time({job=\"nginx\"}[5m])</code> <code>sum_over_time()</code> Sum of values <code>sum_over_time({job=\"nginx\"} | json | unwrap bytes [5m])</code> <code>avg_over_time()</code> Average <code>avg_over_time({job=\"nginx\"} | json | unwrap duration [5m])</code> <code>max_over_time()</code> Maximum <code>max_over_time({job=\"nginx\"} | json | unwrap duration [5m])</code> <code>min_over_time()</code> Minimum <code>min_over_time({job=\"nginx\"} | json | unwrap duration [5m])</code> <code>stdvar_over_time()</code> Standard variance <code>stdvar_over_time({job=\"nginx\"} | json | unwrap duration [5m])</code> <code>stddev_over_time()</code> Standard deviation <code>stddev_over_time({job=\"nginx\"} | json | unwrap duration [5m])</code> <code>quantile_over_time()</code> Quantile <code>quantile_over_time(0.95, {job=\"nginx\"} | json | unwrap duration [5m])</code>"},{"location":"cheatsheets/logQL/#unwrap","title":"Unwrap","text":"<p>Extract numeric values from logs:</p> PromQL<pre><code># Sum response times\nsum_over_time(\n  {job=\"nginx\"} \n    | json \n    | unwrap duration [5m]\n)\n\n# Average bytes\navg_over_time(\n  {job=\"nginx\"} \n    | json \n    | unwrap bytes [5m]\n)\n\n# P95 latency\nquantile_over_time(0.95,\n  {job=\"nginx\"} \n    | json \n    | unwrap duration [5m]\n)\n</code></pre>"},{"location":"cheatsheets/logQL/#unit-conversion","title":"Unit Conversion","text":"PromQL<pre><code># Convert bytes to MB\nsum_over_time(\n  {job=\"nginx\"} \n    | json \n    | unwrap bytes [5m]\n) / 1024 / 1024\n\n# Convert milliseconds to seconds\navg_over_time(\n  {job=\"app\"} \n    | json \n    | unwrap duration_ms [5m]\n) / 1000\n</code></pre>"},{"location":"cheatsheets/logQL/#aggregation-operators","title":"Aggregation Operators","text":""},{"location":"cheatsheets/logQL/#basic-aggregation","title":"Basic Aggregation","text":"PromQL<pre><code># Sum across streams\nsum(rate({job=\"nginx\"}[5m]))\n\n# Average\navg(rate({job=\"nginx\"}[5m]))\n\n# Count\ncount(count_over_time({job=\"nginx\"}[5m]))\n\n# Min/Max\nmin(rate({job=\"nginx\"}[5m]))\nmax(rate({job=\"nginx\"}[5m]))\n</code></pre>"},{"location":"cheatsheets/logQL/#group-by","title":"Group By","text":"PromQL<pre><code># Group by label\nsum by (namespace) (rate({job=\"nginx\"}[5m]))\n\n# Group by multiple labels\nsum by (namespace, pod) (rate({job=\"nginx\"}[5m]))\n\n# Group without\nsum without (instance) (rate({job=\"nginx\"}[5m]))\n</code></pre>"},{"location":"cheatsheets/logQL/#topbottom-k","title":"Top/Bottom K","text":"PromQL<pre><code># Top 5 namespaces by log volume\ntopk(5, sum by (namespace) (rate({job=\"nginx\"}[5m])))\n\n# Bottom 3 services\nbottomk(3, sum by (service) (rate({job=\"app\"}[5m])))\n</code></pre>"},{"location":"cheatsheets/logQL/#common-queries","title":"Common Queries","text":""},{"location":"cheatsheets/logQL/#error-rate","title":"Error Rate","text":"PromQL<pre><code># Error logs per second\nsum(rate({job=\"app\"} |= \"error\" [5m]))\n\n# Error rate by service\nsum by (service) (rate({job=\"app\"} |= \"error\" [5m]))\n\n# Error percentage\n(\n  sum(rate({job=\"app\"} |= \"error\" [5m]))\n  /\n  sum(rate({job=\"app\"}[5m]))\n) * 100\n</code></pre>"},{"location":"cheatsheets/logQL/#http-status-analysis","title":"HTTP Status Analysis","text":"PromQL<pre><code># 5xx errors per second\nsum(rate({job=\"nginx\"} | json | status &gt;= 500 [5m]))\n\n# Requests by status code\nsum by (status) (\n  count_over_time({job=\"nginx\"} | json [5m])\n)\n\n# 4xx error rate\nsum(rate({job=\"nginx\"} | json | status &gt;= 400 | status &lt; 500 [5m]))\n</code></pre>"},{"location":"cheatsheets/logQL/#latency-metrics","title":"Latency Metrics","text":"PromQL<pre><code># Average response time\navg(\n  avg_over_time(\n    {job=\"nginx\"} | json | unwrap duration [5m]\n  )\n)\n\n# P95 latency\nquantile_over_time(0.95,\n  {job=\"nginx\"} | json | unwrap duration [5m]\n)\n\n# P99 latency by endpoint\nquantile_over_time(0.99,\n  {job=\"api\"} | json | unwrap duration [5m]\n) by (path)\n</code></pre>"},{"location":"cheatsheets/logQL/#log-volume","title":"Log Volume","text":"PromQL<pre><code># Total logs per second\nsum(rate({namespace=\"production\"}[5m]))\n\n# Logs per second by job\nsum by (job) (rate({namespace=\"production\"}[5m]))\n\n# Top 10 noisiest pods\ntopk(10, \n  sum by (pod) (rate({namespace=\"production\"}[5m]))\n)\n</code></pre>"},{"location":"cheatsheets/logQL/#pattern-detection","title":"Pattern Detection","text":"PromQL<pre><code># Find specific error patterns\n{job=\"app\"} |~ \"(?i)(error|exception|fatal)\"\n\n# Database errors\n{job=\"app\"} |~ \"(?i)(deadlock|timeout|connection.*failed)\"\n\n# Auth failures\n{job=\"app\"} |~ \"(?i)(unauthorized|forbidden|authentication.*failed)\"\n</code></pre>"},{"location":"cheatsheets/logQL/#alert-patterns","title":"Alert Patterns","text":""},{"location":"cheatsheets/logQL/#high-error-rate","title":"High Error Rate","text":"PromQL<pre><code># Alert if error rate &gt; 5%\n(\n  sum(rate({job=\"app\"} |= \"error\" [5m]))\n  /\n  sum(rate({job=\"app\"}[5m]))\n) &gt; 0.05\n</code></pre>"},{"location":"cheatsheets/logQL/#specific-error-pattern","title":"Specific Error Pattern","text":"PromQL<pre><code># Alert on critical errors\nsum(rate({job=\"app\"} |~ \"(?i)critical|fatal\" [5m])) &gt; 0\n</code></pre>"},{"location":"cheatsheets/logQL/#log-volume-anomaly","title":"Log Volume Anomaly","text":"PromQL<pre><code># Alert if logs drop significantly\nsum(rate({job=\"app\"}[5m]))\n&lt;\nsum(rate({job=\"app\"}[5m] offset 1h)) * 0.5\n</code></pre>"},{"location":"cheatsheets/logQL/#high-latency","title":"High Latency","text":"PromQL<pre><code># Alert if P95 &gt; 500ms\nquantile_over_time(0.95,\n  {job=\"api\"} | json | unwrap duration_ms [5m]\n) &gt; 500\n</code></pre>"},{"location":"cheatsheets/logQL/#advanced-patterns","title":"Advanced Patterns","text":""},{"location":"cheatsheets/logQL/#detect-anomalies","title":"Detect Anomalies","text":"PromQL<pre><code># Compare to historical baseline\nsum(rate({job=\"app\"} |= \"error\" [5m]))\n/\nsum(rate({job=\"app\"} |= \"error\" [5m] offset 1d))\n&gt; 2\n</code></pre>"},{"location":"cheatsheets/logQL/#multi-service-correlation","title":"Multi-Service Correlation","text":"PromQL<pre><code># Errors across multiple services\nsum by (service) (\n  rate({namespace=\"production\"} |= \"error\" [5m])\n)\n</code></pre>"},{"location":"cheatsheets/logQL/#time-based-analysis","title":"Time-Based Analysis","text":"PromQL<pre><code># Hour-over-hour comparison\nsum(rate({job=\"app\"}[5m]))\n/\nsum(rate({job=\"app\"}[5m] offset 1h))\n</code></pre>"},{"location":"cheatsheets/logQL/#performance-tips","title":"Performance Tips","text":"<p>Query Optimization</p> <ol> <li>Filter early - Use stream selectors first</li> <li>Limit time ranges - Smaller ranges = faster queries</li> <li>Use specific labels - Add job/namespace to reduce streams</li> <li>Avoid expensive regex - Use simple filters when possible</li> <li>Aggregate when needed - Don't return raw logs for metrics</li> </ol>"},{"location":"cheatsheets/logQL/#good-vs-bad","title":"Good vs Bad","text":"BadGood PromQL<pre><code># Too broad, no filtering\n{namespace=\"production\"}\n\n# Complex regex on all logs\n{job=\"app\"} |~ \".*error.*warning.*\"\n\n# Long time range with no aggregation\n{job=\"app\"}[24h]\n</code></pre> PromQL<pre><code># Specific stream, early filter\n{job=\"app\", namespace=\"production\"} |= \"error\"\n\n# Simple filter\n{job=\"app\"} |= \"error\"\n\n# Aggregated over reasonable range\nsum(rate({job=\"app\"} |= \"error\" [5m]))\n</code></pre>"},{"location":"cheatsheets/logQL/#label-operations","title":"Label Operations","text":""},{"location":"cheatsheets/logQL/#drop-labels","title":"Drop Labels","text":"PromQL<pre><code># Remove label from result\n{job=\"app\"} | json | label_format pod=\"\"\n</code></pre>"},{"location":"cheatsheets/logQL/#rename-labels","title":"Rename Labels","text":"PromQL<pre><code># Rename label\n{job=\"app\"} | json | label_format new_name=`{{.old_name}}`\n</code></pre>"},{"location":"cheatsheets/logQL/#conditional-labels","title":"Conditional Labels","text":"PromQL<pre><code># Add label based on condition\n{job=\"nginx\"} \n  | json \n  | label_format error_type=`{{ if eq .status \"500\" }}server{{ else }}client{{ end }}`\n</code></pre>"},{"location":"cheatsheets/logQL/#comparison-promql-vs-logql","title":"Comparison: PromQL vs LogQL","text":"Feature PromQL LogQL Data source Metrics Logs Query start Metric name Label selector Filters Label matchers Line filters + label matchers Parsing N/A json, logfmt, regexp, pattern Aggregation On metrics On log streams Functions Math/statistics Log-specific + similar to PromQL"},{"location":"cheatsheets/logQL/#common-mistakes","title":"Common Mistakes","text":"<p>Avoid These</p> <p>Forgetting to parse PromQL<pre><code># WRONG - status not available\n{job=\"app\"} | status=\"500\"\n\n# CORRECT - parse first\n{job=\"app\"} | json | status=\"500\"\n</code></pre></p> <p>Using wrong function on logs PromQL<pre><code># WRONG - rate() needs range vector\nrate({job=\"app\"})\n\n# CORRECT\nrate({job=\"app\"}[5m])\n</code></pre></p> <p>Too broad selectors PromQL<pre><code># WRONG - matches everything\n{}\n\n# CORRECT - specific selector\n{job=\"app\", namespace=\"production\"}\n</code></pre></p>"},{"location":"cheatsheets/logQL/#quick-reference","title":"Quick Reference","text":"Task Query Get logs <code>{job=\"nginx\"}</code> Filter errors <code>{job=\"app\"} |= \"error\"</code> Parse JSON <code>{job=\"app\"} | json</code> Error rate <code>sum(rate({job=\"app\"} |= \"error\" [5m]))</code> Log count <code>count_over_time({job=\"app\"}[5m])</code> P95 latency <code>quantile_over_time(0.95, {job=\"app\"} | json | unwrap duration [5m])</code> Top pods by volume <code>topk(10, sum by (pod) (rate({job=\"app\"}[5m])))</code> Pattern search <code>{job=\"app\"} |~ \"(?i)error|exception\"</code> HTTP 5xx rate <code>sum(rate({job=\"nginx\"} | json | status &gt;= 500 [5m]))</code>"},{"location":"cheatsheets/mkdocs_cheatsheet/","title":"Mkdocs - Material cheatsheet","text":"<p>Complete reference for all enabled extensions and features.</p>"},{"location":"cheatsheets/mkdocs_cheatsheet/#table-of-contents","title":"Table of Contents","text":"<p>Use <code>[TOC]</code> or it auto-generates from headers with <code>permalink: true</code>.</p>"},{"location":"cheatsheets/mkdocs_cheatsheet/#code-blocks","title":"Code Blocks","text":""},{"location":"cheatsheets/mkdocs_cheatsheet/#basic-syntax-highlighting","title":"Basic Syntax Highlighting","text":"<p>Supported languages: <code>promql</code>, <code>go</code>, <code>bash</code>, <code>python</code>, <code>yaml</code>, <code>json</code>, <code>dockerfile</code>, etc.</p> PromQL<pre><code># PromQL query\nrate(http_requests_total{job=\"api\"}[5m])\n</code></pre> Go<pre><code>// Golang example\nfunc main() {\n    fmt.Println(\"Hello World\")\n}\n</code></pre> Bash<pre><code># Bash commands\nkubectl get pods -n monitoring\nsystemctl status prometheus\n</code></pre> <p>Markdown source: Markdown<pre><code>```promql\nrate(http_requests_total[5m])\n```\n</code></pre></p>"},{"location":"cheatsheets/mkdocs_cheatsheet/#code-blocks-with-line-numbers","title":"Code Blocks with Line Numbers","text":"<p>Add line numbers to any code block:</p> Python<pre><code>def fibonacci(n):\n    if n &lt;= 1:\n        return n\n    return fibonacci(n-1) + fibonacci(n-2)\n\nresult = fibonacci(10)\nprint(f\"Result: {result}\")\n</code></pre> <p>Markdown source: Markdown<pre><code>```python linenums=\"1\"\ndef fibonacci(n):\n    return n if n &lt;= 1 else fibonacci(n-1) + fibonacci(n-2)\n```\n</code></pre></p>"},{"location":"cheatsheets/mkdocs_cheatsheet/#highlighting-specific-lines","title":"Highlighting Specific Lines","text":"<p>Highlight important lines:</p> YAML<pre><code>apiVersion: v1\nkind: Service  # This line is highlighted\nmetadata:\n  name: prometheus  # These lines\n  namespace: monitoring  # are also\n  labels:  # highlighted\n    app: prometheus\n</code></pre> <p>Markdown source: Markdown<pre><code>```yaml hl_lines=\"2 4-6\"\napiVersion: v1\nkind: Service\n```\n</code></pre></p>"},{"location":"cheatsheets/mkdocs_cheatsheet/#code-with-title","title":"Code with Title","text":"fibonacci.py<pre><code>def fibonacci(n):\n    \"\"\"Calculate fibonacci number.\"\"\"\n    if n &lt;= 1:\n        return n\n    return fibonacci(n-1) + fibonacci(n-2)\n</code></pre> <p>Markdown source: Markdown<pre><code>```python title=\"fibonacci.py\"\ndef fibonacci(n):\n    return n\n```\n</code></pre></p>"},{"location":"cheatsheets/mkdocs_cheatsheet/#code-annotations","title":"Code Annotations","text":"<p>Add inline explanations to code:</p> YAML<pre><code>apiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: nginx  # (1)!\nspec:\n  replicas: 3  # (2)!\n  selector:\n    matchLabels:\n      app: nginx\n</code></pre> <ol> <li>The name of your deployment</li> <li>Number of pod replicas</li> </ol> <p>Markdown source: Markdown<pre><code>```yaml\nmetadata:\n  name: nginx  # (1)!\n```\n\n1. The name of your deployment\n</code></pre></p>"},{"location":"cheatsheets/mkdocs_cheatsheet/#inline-code-highlighting","title":"Inline Code Highlighting","text":"<p>Use inline syntax highlighting with backticks and language: <code>range(10)</code> or <code>curl -X GET</code>.</p> <p>Markdown source: Markdown<pre><code>Use `#!python range(10)` for inline code.\n</code></pre></p>"},{"location":"cheatsheets/mkdocs_cheatsheet/#admonitions-info-boxes","title":"Admonitions (Info Boxes)","text":""},{"location":"cheatsheets/mkdocs_cheatsheet/#basic-admonitions","title":"Basic Admonitions","text":"<p>Note</p> <p>This is a note admonition. Use it for general information.</p> <p>Tip</p> <p>This is a tip admonition. Use it for helpful suggestions.</p> <p>Warning</p> <p>This is a warning admonition. Use it for important cautions.</p> <p>Danger</p> <p>This is a danger admonition. Use it for critical warnings.</p> <p>Markdown source: Markdown<pre><code>!!! note\n    This is a note admonition.\n\n!!! warning\n    This is a warning admonition.\n</code></pre></p>"},{"location":"cheatsheets/mkdocs_cheatsheet/#custom-titles","title":"Custom Titles","text":"<p>PromQL Pro Tip</p> <p>Always use <code>rate()</code> for counters, never raw values.</p> <p>Markdown source: Markdown<pre><code>!!! tip \"PromQL Pro Tip\"\n    Always use `rate()` for counters.\n</code></pre></p>"},{"location":"cheatsheets/mkdocs_cheatsheet/#collapsible-admonitions","title":"Collapsible Admonitions","text":"<p>Use <code>???</code> instead of <code>!!!</code> to make them collapsible:</p> Click to expand <p>This content is hidden by default. Users must click to see it.</p> Critical Performance Issue <p>Querying large time ranges without aggregation can crash Prometheus.</p> PromQL<pre><code># Bad - queries all series\nhttp_requests_total\n\n# Good - aggregated\nsum(rate(http_requests_total[5m]))\n</code></pre> <p>Markdown source: Markdown<pre><code>??? note \"Click to expand\"\n    This content is hidden by default.\n</code></pre></p>"},{"location":"cheatsheets/mkdocs_cheatsheet/#inline-blocks-already-expanded","title":"Inline Blocks (Already Expanded)","text":"Pre-expanded Tip <p>Use <code>???+</code> to make collapsible blocks expanded by default.</p> <p>Markdown source: Markdown<pre><code>???+ tip \"Pre-expanded Tip\"\n    Content here starts visible.\n</code></pre></p>"},{"location":"cheatsheets/mkdocs_cheatsheet/#content-tabs","title":"Content Tabs","text":"<p>Compare different approaches side-by-side:</p> PromQLLogQLBash PromQL<pre><code>rate(http_requests_total[5m])\n</code></pre> PromQL<pre><code>rate({job=\"nginx\"}[5m])\n</code></pre> Bash<pre><code>curl -s localhost:9090/api/v1/query?query=up\n</code></pre> <p>Markdown source: Markdown<pre><code>=== \"PromQL\"\n    ```promql\n    rate(http_requests_total[5m])\n    ```\n\n=== \"LogQL\"\n    ```promql\n    rate({job=\"nginx\"}[5m])\n    ```\n</code></pre></p>"},{"location":"cheatsheets/mkdocs_cheatsheet/#nested-tabs","title":"Nested Tabs","text":"MonitoringLogging PrometheusGrafana YAML<pre><code>scrape_configs:\n  - job_name: 'api'\n    static_configs:\n      - targets: ['localhost:8080']\n</code></pre> JSON<pre><code>{\n  \"datasource\": \"Prometheus\",\n  \"expr\": \"rate(http_requests[5m])\"\n}\n</code></pre> Loki YAML<pre><code>auth_enabled: false\nserver:\n  http_listen_port: 3100\n</code></pre> <p>Markdown source: Markdown<pre><code>=== \"Monitoring\"\n    === \"Prometheus\"\n        Content here\n    === \"Grafana\"\n        Content here\n</code></pre></p>"},{"location":"cheatsheets/mkdocs_cheatsheet/#keyboard-keys","title":"Keyboard Keys","text":"<p>Press Ctrl+C to copy or Ctrl+Shift+P to open command palette.</p> <p>Common shortcuts: - Save: Ctrl+S - Quit: Ctrl+Q - Search: Ctrl+F - Terminal: Ctrl+`</p> <p>Markdown source: Markdown<pre><code>Press ++ctrl+c++ to copy.\nPress ++ctrl+shift+p++ for command palette.\n</code></pre></p>"},{"location":"cheatsheets/mkdocs_cheatsheet/#snippets-reusable-content","title":"Snippets (Reusable Content)","text":"<p>Create reusable content in separate files:</p> <p>File: <code>docs/snippets/common-queries.md</code> PromQL<pre><code># CPU Usage\n100 - (avg by (instance) (rate(node_cpu_seconds_total{mode=\"idle\"}[5m])) * 100)\n\n# Memory Usage\n(1 - (node_memory_MemAvailable_bytes / node_memory_MemTotal_bytes)) * 100\n</code></pre></p> <p>Include in any page: Markdown<pre><code>\n</code></pre></p> <p>Markdown source: Markdown<pre><code>\n</code></pre></p>"},{"location":"cheatsheets/mkdocs_cheatsheet/#combining-features","title":"Combining Features","text":"<p>Here's a complex example using multiple features:</p> <p>Complete Monitoring Setup</p> Prometheus ConfigQuery Examples prometheus.yml<pre><code>global:\n  scrape_interval: 15s  # (1)!\nscrape_configs:\n  - job_name: 'kubernetes-pods'  # (2)!\n    kubernetes_sd_configs:\n      - role: pod\n</code></pre> <ol> <li>How often to scrape targets</li> <li>Auto-discover Kubernetes pods</li> </ol> PromQL<pre><code># Request rate per service\nsum by (service) (rate(http_requests_total[5m]))\n\n# P95 latency\nhistogram_quantile(0.95, \n  sum by (le) (rate(http_request_duration_seconds_bucket[5m]))\n)\n</code></pre> <p>Tip</p> <p>Test queries in Prometheus UI before adding to Grafana dashboards.</p>"},{"location":"cheatsheets/mkdocs_cheatsheet/#best-practices-summary","title":"Best Practices Summary","text":"Quick Reference <p>Code Blocks: - Use line numbers for long snippets: <code>linenums=\"1\"</code> - Highlight important lines: <code>hl_lines=\"2 4-6\"</code> - Add titles for context: <code>title=\"config.yaml\"</code></p> <p>Organization: - Use tabs for comparing alternatives - Use admonitions for warnings/tips - Make long sections collapsible with <code>???</code></p> <p>Keyboard Shortcuts: - Format: <code>++ctrl+shift+p++</code> - Separate keys with <code>+</code></p> <p>Inline Code: - Add syntax highlighting: <code>`#!python print()`</code></p>"},{"location":"cheatsheets/mkdocs_cheatsheet/#common-admonition-types","title":"Common Admonition Types","text":"<p>Note</p> <p>General information</p> <p>Abstract</p> <p>Summary or TL;DR</p> <p>Info</p> <p>Additional context</p> <p>Tip</p> <p>Helpful suggestions</p> <p>Success</p> <p>Positive outcome</p> <p>Question</p> <p>Questions or help needed</p> <p>Warning</p> <p>Important cautions</p> <p>Failure</p> <p>Errors or failures</p> <p>Danger</p> <p>Critical warnings</p> <p>Bug</p> <p>Known issues</p> <p>Example</p> <p>Code examples</p> <p>Quote</p> <p>Citations or quotes</p>"},{"location":"cheatsheets/mkdocs_cheatsheet/#markdown-source-template","title":"Markdown Source Template","text":"Markdown<pre><code># Your Page Title\n\n## Section\n\nRegular paragraph with `inline code`.\n\n### Code Example\n\n```bash\ncommand --flag value\n</code></pre>"},{"location":"cheatsheets/mkdocs_cheatsheet/#info-box","title":"Info Box","text":"<p>Helpful Tip</p> <p>Your tip content here.</p>"},{"location":"cheatsheets/mkdocs_cheatsheet/#tabs","title":"Tabs","text":"Option 1Option 2 <p>Content for option 1</p> <p>Content for option 2</p>"},{"location":"cheatsheets/mkdocs_cheatsheet/#keyboard","title":"Keyboard","text":"<p>Press Ctrl+C to copy. ```</p>"},{"location":"cheatsheets/promQL/","title":"PromQL Cheat Sheet","text":"<p>Prometheus Query Language reference for monitoring and alerting.</p>"},{"location":"cheatsheets/promQL/#metric-types","title":"Metric Types","text":"Type Description Use Case Counter Monotonically increasing value Request counts, errors Gauge Value that can go up or down CPU usage, memory, temperature Histogram Distribution of observations Request latency, response sizes Summary Similar to histogram with quantiles Precomputed percentiles"},{"location":"cheatsheets/promQL/#data-types","title":"Data Types","text":"<p>Instant Vector - Set of time series at a single timestamp PromQL<pre><code>http_requests_total\n</code></pre></p> <p>Range Vector - Set of time series over a time range PromQL<pre><code>http_requests_total[5m]\n</code></pre></p> <p>Scalar - Simple numeric value PromQL<pre><code>5\n</code></pre></p> <p>String - String literal (rarely used) PromQL<pre><code>\"error\"\n</code></pre></p>"},{"location":"cheatsheets/promQL/#selectors","title":"Selectors","text":""},{"location":"cheatsheets/promQL/#label-matching","title":"Label Matching","text":"EqualityInequalityRegex PromQL<pre><code># Exact match\nhttp_requests_total{method=\"GET\"}\n\n# Multiple labels\nhttp_requests_total{method=\"GET\", status=\"200\"}\n</code></pre> PromQL<pre><code># Not equal\nhttp_requests_total{status!=\"200\"}\n</code></pre> PromQL<pre><code># Regex match\nhttp_requests_total{status=~\"5..\"}\n\n# Negative regex\nhttp_requests_total{status!~\"2..\"}\n</code></pre>"},{"location":"cheatsheets/promQL/#time-ranges","title":"Time Ranges","text":"PromQL<pre><code># 5 minutes\nhttp_requests_total[5m]\n\n# 1 hour\nhttp_requests_total[1h]\n\n# 1 day\nhttp_requests_total[1d]\n\n# Units: s, m, h, d, w, y\n</code></pre>"},{"location":"cheatsheets/promQL/#rate-functions","title":"Rate Functions","text":"<p>Counter vs Gauge</p> <p>Use <code>rate()</code> and <code>increase()</code> only with counters, never with gauges.</p>"},{"location":"cheatsheets/promQL/#rate","title":"rate()","text":"<p>Calculate per-second rate over time range:</p> PromQL<pre><code># Requests per second\nrate(http_requests_total[5m])\n\n# With labels\nrate(http_requests_total{job=\"api\"}[5m])\n</code></pre>"},{"location":"cheatsheets/promQL/#irate","title":"irate()","text":"<p>Instant rate using last two data points (more sensitive to spikes):</p> PromQL<pre><code>irate(http_requests_total[5m])\n</code></pre> <p>When to Use</p> <ul> <li><code>rate()</code> - Smooth graphs, alerts, aggregations</li> <li><code>irate()</code> - Volatile metrics, spike detection</li> </ul>"},{"location":"cheatsheets/promQL/#increase","title":"increase()","text":"<p>Total increase over time range:</p> PromQL<pre><code># Total requests in last 5 minutes\nincrease(http_requests_total[5m])\n\n# Requests in last hour\nincrease(http_requests_total[1h])\n</code></pre>"},{"location":"cheatsheets/promQL/#aggregation-operators","title":"Aggregation Operators","text":""},{"location":"cheatsheets/promQL/#basic-aggregation","title":"Basic Aggregation","text":"PromQL<pre><code># Sum across all instances\nsum(rate(http_requests_total[5m]))\n\n# Average\navg(rate(http_requests_total[5m]))\n\n# Minimum\nmin(http_requests_total)\n\n# Maximum\nmax(http_requests_total)\n\n# Count\ncount(up == 1)\n</code></pre>"},{"location":"cheatsheets/promQL/#aggregation-by-labels","title":"Aggregation by Labels","text":"sum bysum without PromQL<pre><code># Sum per service\nsum by (service) (rate(http_requests_total[5m]))\n\n# Sum per service and method\nsum by (service, method) (rate(http_requests_total[5m]))\n</code></pre> PromQL<pre><code># Sum, removing instance label\nsum without (instance) (rate(http_requests_total[5m]))\n</code></pre>"},{"location":"cheatsheets/promQL/#all-aggregation-functions","title":"All Aggregation Functions","text":"PromQL<pre><code>sum()       # Sum of all values\navg()       # Average\nmin()       # Minimum\nmax()       # Maximum\ncount()     # Count of elements\nstddev()    # Standard deviation\nstdvar()    # Standard variance\ntopk(N)     # Top N elements\nbottomk(N)  # Bottom N elements\nquantile()  # Calculate quantile\n</code></pre>"},{"location":"cheatsheets/promQL/#binary-operators","title":"Binary Operators","text":""},{"location":"cheatsheets/promQL/#arithmetic","title":"Arithmetic","text":"PromQL<pre><code># Addition\nnode_memory_MemTotal_bytes - node_memory_MemFree_bytes\n\n# Percentage\n(1 - (node_memory_MemAvailable_bytes / node_memory_MemTotal_bytes)) * 100\n\n# Division\nrate(http_requests_total[5m]) / rate(http_requests_total[5m] offset 1h)\n</code></pre>"},{"location":"cheatsheets/promQL/#comparison","title":"Comparison","text":"PromQL<pre><code># Greater than\nup &gt; 0\n\n# Less than\nnode_load1 &lt; 0.8\n\n# Equal\nhttp_response_status == 200\n\n# Not equal\nhttp_response_status != 200\n</code></pre>"},{"location":"cheatsheets/promQL/#logical","title":"Logical","text":"PromQL<pre><code># AND\nup == 1 and on(instance) node_load1 &gt; 0.8\n\n# OR\nup == 0 or node_load1 &gt; 1.0\n\n# UNLESS\nup == 1 unless node_load1 &gt; 0.8\n</code></pre>"},{"location":"cheatsheets/promQL/#vector-matching","title":"Vector Matching","text":""},{"location":"cheatsheets/promQL/#one-to-one","title":"One-to-One","text":"PromQL<pre><code># Match by instance and job\nmethod:http_requests:rate5m{method=\"GET\"} \n  / ignoring(method) \n  method:http_requests:rate5m\n</code></pre>"},{"location":"cheatsheets/promQL/#many-to-one","title":"Many-to-One","text":"PromQL<pre><code># Match multiple pods to one node\nrate(container_cpu_usage[5m]) \n  * on(instance) group_left(node_name) \n  node_metadata\n</code></pre>"},{"location":"cheatsheets/promQL/#common-queries","title":"Common Queries","text":""},{"location":"cheatsheets/promQL/#cpu-usage","title":"CPU Usage","text":"PromQL<pre><code># CPU usage by instance\n100 - (avg by (instance) (rate(node_cpu_seconds_total{mode=\"idle\"}[5m])) * 100)\n\n# CPU usage by mode\nsum by (mode) (rate(node_cpu_seconds_total[5m]))\n</code></pre>"},{"location":"cheatsheets/promQL/#memory-usage","title":"Memory Usage","text":"PromQL<pre><code># Memory usage percentage\n(1 - (node_memory_MemAvailable_bytes / node_memory_MemTotal_bytes)) * 100\n\n# Available memory in GB\nnode_memory_MemAvailable_bytes / 1024^3\n</code></pre>"},{"location":"cheatsheets/promQL/#disk-usage","title":"Disk Usage","text":"PromQL<pre><code># Disk usage percentage\n(1 - (node_filesystem_avail_bytes / node_filesystem_size_bytes)) * 100\n\n# Disk I/O rate\nrate(node_disk_read_bytes_total[5m])\nrate(node_disk_written_bytes_total[5m])\n</code></pre>"},{"location":"cheatsheets/promQL/#network","title":"Network","text":"PromQL<pre><code># Network receive rate in MB/s\nrate(node_network_receive_bytes_total[5m]) / 1024^2\n\n# Network transmit rate\nrate(node_network_transmit_bytes_total[5m]) / 1024^2\n</code></pre>"},{"location":"cheatsheets/promQL/#request-metrics","title":"Request Metrics","text":"PromQL<pre><code># Request rate\nsum(rate(http_requests_total[5m]))\n\n# Error rate\nsum(rate(http_requests_total{status=~\"5..\"}[5m]))\n\n# Error percentage\n(\n  sum(rate(http_requests_total{status=~\"5..\"}[5m]))\n  /\n  sum(rate(http_requests_total[5m]))\n) * 100\n\n# Requests per second by service\nsum by (service) (rate(http_requests_total[5m]))\n</code></pre>"},{"location":"cheatsheets/promQL/#histogram-functions","title":"Histogram Functions","text":""},{"location":"cheatsheets/promQL/#histogram_quantile","title":"histogram_quantile()","text":"<p>Calculate quantiles from histogram buckets:</p> PromQL<pre><code># P95 latency\nhistogram_quantile(0.95,\n  sum by (le) (rate(http_request_duration_seconds_bucket[5m]))\n)\n\n# P50 latency\nhistogram_quantile(0.50,\n  rate(http_request_duration_seconds_bucket[5m])\n)\n\n# P99 latency by service\nhistogram_quantile(0.99,\n  sum by (service, le) (rate(http_request_duration_seconds_bucket[5m]))\n)\n</code></pre>"},{"location":"cheatsheets/promQL/#histogram-bucket-functions","title":"Histogram Bucket Functions","text":"PromQL<pre><code># Average request duration\nrate(http_request_duration_seconds_sum[5m])\n/\nrate(http_request_duration_seconds_count[5m])\n</code></pre>"},{"location":"cheatsheets/promQL/#time-functions","title":"Time Functions","text":""},{"location":"cheatsheets/promQL/#offset","title":"offset","text":"<p>Query data from the past:</p> PromQL<pre><code># Current vs 1 hour ago\nhttp_requests_total offset 1h\n\n# Compare current rate to rate 1 day ago\nrate(http_requests_total[5m])\n/\nrate(http_requests_total[5m] offset 1d)\n</code></pre>"},{"location":"cheatsheets/promQL/#time-manipulation","title":"Time Manipulation","text":"PromQL<pre><code>time()              # Current timestamp\nminute()            # Current minute (0-59)\nhour()              # Current hour (0-23)\nday_of_week()       # Day of week (0-6, Sunday=0)\nday_of_month()      # Day of month (1-31)\ndays_in_month()     # Days in current month\nmonth()             # Current month (1-12)\nyear()              # Current year\n</code></pre>"},{"location":"cheatsheets/promQL/#useful-functions","title":"Useful Functions","text":""},{"location":"cheatsheets/promQL/#clamp_max-clamp_min","title":"clamp_max / clamp_min","text":"<p>Limit values to range:</p> PromQL<pre><code># Cap at 100\nclamp_max(cpu_usage, 100)\n\n# Floor at 0\nclamp_min(cpu_usage, 0)\n</code></pre>"},{"location":"cheatsheets/promQL/#round","title":"round","text":"<p>Round values:</p> PromQL<pre><code># Round to nearest integer\nround(cpu_usage)\n\n# Round to 1 decimal\nround(cpu_usage, 0.1)\n</code></pre>"},{"location":"cheatsheets/promQL/#absent","title":"absent","text":"<p>Check if metric is missing:</p> PromQL<pre><code># Alert if metric disappears\nabsent(up{job=\"api\"})\n</code></pre>"},{"location":"cheatsheets/promQL/#label_replace","title":"label_replace","text":"<p>Modify labels:</p> PromQL<pre><code>label_replace(\n  up,\n  \"new_label\",\n  \"$1\",\n  \"instance\",\n  \"(.*):.*\"\n)\n</code></pre>"},{"location":"cheatsheets/promQL/#predict_linear","title":"predict_linear","text":"<p>Predict future values:</p> PromQL<pre><code># Predict disk usage in 4 hours\npredict_linear(node_filesystem_free_bytes[1h], 4*3600)\n</code></pre>"},{"location":"cheatsheets/promQL/#subqueries","title":"Subqueries","text":"<p>Execute query over a time range:</p> PromQL<pre><code># Max rate over last hour, calculated per minute\nmax_over_time(\n  rate(http_requests_total[5m])[1h:1m]\n)\n\n# Average of P95 over last day\navg_over_time(\n  histogram_quantile(0.95, rate(http_request_duration_bucket[5m]))[1d:5m]\n)\n</code></pre>"},{"location":"cheatsheets/promQL/#alert-query-patterns","title":"Alert Query Patterns","text":""},{"location":"cheatsheets/promQL/#service-down","title":"Service Down","text":"PromQL<pre><code># Alert if service is down\nup{job=\"api\"} == 0\n\n# Alert if service down for 5 minutes\nup{job=\"api\"} == 0 for 5m\n</code></pre>"},{"location":"cheatsheets/promQL/#high-error-rate","title":"High Error Rate","text":"PromQL<pre><code># Error rate above 5%\n(\n  sum(rate(http_requests_total{status=~\"5..\"}[5m]))\n  /\n  sum(rate(http_requests_total[5m]))\n) &gt; 0.05\n</code></pre>"},{"location":"cheatsheets/promQL/#high-latency","title":"High Latency","text":"PromQL<pre><code># P95 latency above 500ms\nhistogram_quantile(0.95,\n  sum by (le) (rate(http_request_duration_seconds_bucket[5m]))\n) &gt; 0.5\n</code></pre>"},{"location":"cheatsheets/promQL/#resource-exhaustion","title":"Resource Exhaustion","text":"PromQL<pre><code># Disk full in less than 4 hours\npredict_linear(node_filesystem_free_bytes[1h], 4*3600) &lt; 0\n\n# Memory usage above 90%\n(1 - (node_memory_MemAvailable_bytes / node_memory_MemTotal_bytes)) &gt; 0.9\n</code></pre>"},{"location":"cheatsheets/promQL/#performance-tips","title":"Performance Tips","text":"<p>Query Optimization</p> <ol> <li>Limit time ranges - use <code>[5m]</code> instead of <code>[1h]</code> when possible</li> <li>Filter early - add label selectors to reduce cardinality</li> <li>Aggregate before calculation - use <code>sum by</code> before <code>rate()</code></li> <li>Avoid regex when possible - use <code>=</code> instead of <code>=~</code></li> <li>Use recording rules for expensive queries</li> </ol>"},{"location":"cheatsheets/promQL/#good-vs-bad","title":"Good vs Bad","text":"BadGood PromQL<pre><code># High cardinality, no filtering\nrate(http_requests_total[1h])\n\n# Unnecessary regex\nhttp_requests{status=~\"200\"}\n</code></pre> PromQL<pre><code># Filtered and aggregated\nsum by (service) (rate(http_requests_total{job=\"api\"}[5m]))\n\n# Direct match\nhttp_requests{status=\"200\"}\n</code></pre>"},{"location":"cheatsheets/promQL/#common-pitfalls","title":"Common Pitfalls","text":"<p>Avoid These Mistakes</p> <p>Using rate() on gauges PromQL<pre><code># WRONG - rate() only for counters\nrate(node_memory_MemAvailable_bytes[5m])\n</code></pre></p> <p>Forgetting range vectors PromQL<pre><code># WRONG - rate() needs range vector\nrate(http_requests_total)\n\n# CORRECT\nrate(http_requests_total[5m])\n</code></pre></p> <p>Division by zero PromQL<pre><code># Can fail if denominator is zero\nrate(http_errors[5m]) / rate(http_requests[5m])\n\n# Better - handle zero\nrate(http_errors[5m]) / (rate(http_requests[5m]) + 1)\n</code></pre></p>"},{"location":"cheatsheets/promQL/#quick-reference","title":"Quick Reference","text":"Pattern Query Request rate <code>sum(rate(http_requests_total[5m]))</code> Error rate % <code>sum(rate(http_requests{status=~\"5..\"}[5m])) / sum(rate(http_requests[5m])) * 100</code> CPU usage % <code>100 - (avg(rate(node_cpu{mode=\"idle\"}[5m])) * 100)</code> Memory usage % <code>(1 - (node_memory_MemAvailable_bytes / node_memory_MemTotal_bytes)) * 100</code> P95 latency <code>histogram_quantile(0.95, rate(http_duration_bucket[5m]))</code> Disk usage % <code>(1 - (node_filesystem_avail / node_filesystem_size)) * 100</code> Top 5 services by requests <code>topk(5, sum by (service) (rate(http_requests[5m])))</code>"},{"location":"projects/ktsw/main/","title":"KTSW: Kubernetes The Sweaty Way","text":""},{"location":"projects/ktsw/main/#1-vision-general-del-proyecto","title":"1. Visi\u00f3n General del Proyecto","text":"<p>KTSW es una iniciativa de ingenier\u00eda dise\u00f1ada bajo una premisa fundamental: la competencia t\u00e9cnica se forja en la fricci\u00f3n.</p> <p>La mayor\u00eda de los tutoriales y herramientas modernas de DevOps (EKS, GKE, herramientas \"magic-box\") buscan abstraer la complejidad, ofreciendo caminos felices que ocultan el funcionamiento interno de los sistemas. Este proyecto hace lo contrario. El objetivo es construir un entorno de homelab tan t\u00e9cnicamente demandante y granular que la operaci\u00f3n de infraestructuras empresariales de producci\u00f3n parezca trivial en comparaci\u00f3n.</p> <p>Si Linux From Scratch es la forja para entender el sistema operativo, KTSW es la forja para entender la orquestaci\u00f3n de sistemas distribuidos a escala.</p>"},{"location":"projects/ktsw/main/#2-filosofia-de-arquitectura","title":"2. Filosof\u00eda de Arquitectura","text":""},{"location":"projects/ktsw/main/#complejidad-justificada-vs-accidental","title":"Complejidad Justificada vs. Accidental","text":"<p>Es crucial distinguir entre complejidad accidental (configuraciones malas) y complejidad esencial (necesaria para resolver problemas dif\u00edciles). KTSW implementa complejidad esencial de nivel enterprise en un entorno controlado.</p> <p>El Principio de Sobrecarga Progresiva</p> <p>Implementamos tecnolog\u00edas que resuelven problemas de escala masiva (Service Mesh, BGP, Distributed Tracing) aunque la escala de tr\u00e1fico actual no lo requiera obligatoriamente, con el fin de dominar la soluci\u00f3n t\u00e9cnica antes de que el problema operativo aparezca.</p>"},{"location":"projects/ktsw/main/#matriz-de-decisiones-tecnicas","title":"Matriz de Decisiones T\u00e9cnicas","text":"Enfoque Tradicional / F\u00e1cil <ul> <li>LoadBalancers gestionados por la nube (ALB/ELB).</li> <li>Seguridad perimetral b\u00e1sica (Security Groups).</li> <li>Observabilidad reactiva (logs cuando algo falla).</li> <li>Despliegues manuales o scripts imperativos.</li> <li>Networking plano y confiable por defecto.</li> </ul> Enfoque KTSW / Enterprise <ul> <li>Implementaci\u00f3n de BGP y anuncio de rutas propias (MetalLB/FRR).</li> <li>Zero Trust Networking y mTLS estricto intra-cluster.</li> <li>Observabilidad continua basada en eBPF y trazas distribuidas.</li> <li>GitOps estricto con reconciliaci\u00f3n autom\u00e1tica.</li> <li>Network Policies de denegaci\u00f3n por defecto (Default Deny).</li> </ul>"},{"location":"projects/ktsw/main/#3-arquitectura-del-sistema","title":"3. Arquitectura del Sistema","text":"<p>El dise\u00f1o sigue un modelo de capas estrictas de abstracci\u00f3n.</p> Text Only<pre><code>graph TD\n    subgraph Infrastructure [Capa de Infraestructura]\n        Hypervisor[Proxmox VE]\n        Network[VLAN Segmentation]\n        Router[pfSense/OPNsense]\n    end\n\n    subgraph Orchestration [Capa de Orquestaci\u00f3n]\n        K8s[Kubernetes Core]\n        Cilium[Cilium CNI + eBPF]\n        MetalLB[MetalLB BGP]\n    end\n\n    subgraph Platform [Capa de Plataforma]\n        GitOps[FluxCD]\n        Mesh[Linkerd Service Mesh]\n        Ingress[Traefik Ingress]\n        Sec[OPA Gatekeeper]\n    end\n\n    subgraph Observability [Capa de Observabilidad]\n        Loki[Loki - Logs]\n        Tempo[Tempo - Traces]\n        Vic[VictoriaMetrics - Metrics]\n        Graf[Grafana - Visualization]\n    end\n\n    Infrastructure --&gt; Orchestration\n    Orchestration --&gt; Platform\n    Platform --&gt; Observability\n</code></pre>"},{"location":"projects/ktsw/main/#4-stack-tecnologico-detallado","title":"4. Stack Tecnol\u00f3gico Detallado","text":""},{"location":"projects/ktsw/main/#capa-1-infraestructura-y-virtualizacion","title":"Capa 1: Infraestructura y Virtualizaci\u00f3n","text":"<p>El control comienza en el \"metal\". Rechazamos instancias de nube p\u00fablica para forzar el manejo de recursos f\u00edsicos y redes L2/L3.</p>"},{"location":"projects/ktsw/main/#1-proxmox-ve-hypervisor","title":"1. Proxmox VE (Hypervisor)","text":"<ul> <li>Justificaci\u00f3n: Permite la gesti\u00f3n de recursos a nivel de kernel (KVM/LXC) y la simulaci\u00f3n de topolog\u00edas de red complejas mediante Open vSwitch.</li> <li>Objetivo T\u00e9cnico: Comprender la diferencia entre aislamiento por virtualizaci\u00f3n completa y paravirtualizaci\u00f3n, as\u00ed como la gesti\u00f3n de storage pools (ZFS).</li> </ul>"},{"location":"projects/ktsw/main/#2-segmentacion-de-red-vlans-8021q","title":"2. Segmentaci\u00f3n de Red (VLANs 802.1Q)","text":"<p>La red no es plana. Separamos tr\u00e1fico para simular un entorno de centro de datos real.</p> <ul> <li>VLAN 10 (Mgmt): Plano de control, SSH, Proxmox UI.</li> <li>VLAN 20 (Nodes): Tr\u00e1fico de Kubelet, etcd y overlay network.</li> <li>VLAN 30 (Storage): Tr\u00e1fico dedicado iSCSI/NFS/Longhorn para evitar latencia en apps.</li> <li>VLAN 40 (Public): VIPs expuestas por el LoadBalancer.</li> </ul>"},{"location":"projects/ktsw/main/#3-pfsenseopnsense-edge-router","title":"3. pfSense/OPNsense (Edge Router)","text":"<ul> <li>Justificaci\u00f3n: Act\u00faa como gateway perimetral, gestionando VPNs (WireGuard), DNS Resolver (Unbound) y reglas de firewall stateful entre VLANs.</li> </ul>"},{"location":"projects/ktsw/main/#capa-2-kubernetes-networking-cni-bgp","title":"Capa 2: Kubernetes Networking (CNI &amp; BGP)","text":"<p>Aqu\u00ed reside gran parte de la complejidad intencional.</p>"},{"location":"projects/ktsw/main/#4-cilium-cni-security","title":"4. Cilium (CNI &amp; Security)","text":"<p>Utilizamos Cilium para reemplazar <code>kube-proxy</code>.</p> <ul> <li>Tecnolog\u00eda: eBPF (Extended Berkeley Packet Filter).</li> <li>Justificaci\u00f3n: Elimina la dependencia de <code>iptables</code> para el enrutamiento de servicios, permitiendo un throughput mayor y latencia menor. Habilita Hubble para generar un mapa de dependencias de red en tiempo real.</li> </ul>"},{"location":"projects/ktsw/main/#5-metallb-load-balancing","title":"5. MetalLB (Load Balancing)","text":"<ul> <li>Modo: BGP (Border Gateway Protocol).</li> <li>Justificaci\u00f3n: En lugar de usar ARP (Capa 2), configuramos MetalLB para hablar BGP con el router pfSense. Esto permite entender protocolos de enrutamiento din\u00e1mico y ECMP (Equal-Cost Multi-Path) para alta disponibilidad real de IPs de entrada.</li> </ul>"},{"location":"projects/ktsw/main/#capa-3-plataforma-y-gitops","title":"Capa 3: Plataforma y GitOps","text":"<p>La regla de oro: \"Si no est\u00e1 en Git, no existe\". El acceso por SSH a los nodos o el uso de <code>kubectl apply</code> manual est\u00e1 prohibido para operaciones normales.</p>"},{"location":"projects/ktsw/main/#6-fluxcd-gitops-controller","title":"6. FluxCD (GitOps Controller)","text":"<ul> <li>Mecanismo: Reconciliaci\u00f3n continua.</li> <li>Justificaci\u00f3n: El cluster \"tira\" (pull) de la configuraci\u00f3n desde Git. Esto asegura recuperaci\u00f3n ante desastres (DR) inmediata: si el cluster muere, se levanta uno nuevo, se instala Flux, y el estado se restaura solo.</li> </ul>"},{"location":"projects/ktsw/main/#7-tekton-ci-pipelines","title":"7. Tekton (CI Pipelines)","text":"<ul> <li>Diferenciador: A diferencia de Jenkins o GitHub Actions, Tekton corre dentro del cluster como recursos nativos (CRDs).</li> <li>Justificaci\u00f3n: Unifica el plano de control de la infraestructura y el del despliegue de software. Permite construir im\u00e1genes (con Kaniko) y desplegarlas sin salir del entorno de Kubernetes.</li> </ul>"},{"location":"projects/ktsw/main/#8-harbor-container-registry","title":"8. Harbor (Container Registry)","text":"<ul> <li>Funcionalidad: Almacenamiento de im\u00e1genes, escaneo de vulnerabilidades (Trivy) y firma de im\u00e1genes (Notary/Cosign).</li> <li>Justificaci\u00f3n: Control total de la cadena de suministro de software (Software Supply Chain).</li> </ul>"},{"location":"projects/ktsw/main/#capa-4-seguridad-y-politicas","title":"Capa 4: Seguridad y Pol\u00edticas","text":""},{"location":"projects/ktsw/main/#9-opa-gatekeeper-policy-engine","title":"9. OPA Gatekeeper (Policy Engine)","text":"<ul> <li>Concepto: Policy as Code.</li> <li>Implementaci\u00f3n: Reglas escritas en lenguaje Rego que interceptan las peticiones al API Server.</li> <li>Casos de uso: Prohibir contenedores corriendo como <code>root</code>, exigir l\u00edmites de recursos (CPU/RAM) y validar procedencia de im\u00e1genes.</li> </ul>"},{"location":"projects/ktsw/main/#10-gestion-de-secretos-sops-age","title":"10. Gesti\u00f3n de Secretos (SOPS + Age)","text":"<ul> <li>Justificaci\u00f3n: Permite almacenar secretos en repositorios p\u00fablicos o privados de forma segura. Los secretos se desencriptan \u00fanicamente dentro del cluster por el controlador de Flux.</li> </ul>"},{"location":"projects/ktsw/main/#capa-5-observabilidad-stack-lgtm","title":"Capa 5: Observabilidad (Stack LGTM)","text":"<p>No es suficiente saber que algo fall\u00f3; es necesario saber por qu\u00e9, d\u00f3nde y cu\u00e1ndo con precisi\u00f3n de milisegundos.</p>"},{"location":"projects/ktsw/main/#11-victoriametrics-metricas","title":"11. VictoriaMetrics (M\u00e9tricas)","text":"<ul> <li>Selecci\u00f3n: Elegido sobre Prometheus por su eficiencia en almacenamiento y capacidad para manejar alta cardinalidad (\"High Cardinality\").</li> </ul>"},{"location":"projects/ktsw/main/#12-loki-logs","title":"12. Loki (Logs)","text":"<ul> <li>Filosof\u00eda: \"Like Prometheus, but for logs\". No indexa el texto completo, solo metadatos, permitiendo correlaci\u00f3n directa entre picos de m\u00e9tricas y l\u00edneas de logs mediante LogQL.</li> </ul>"},{"location":"projects/ktsw/main/#13-tempo-trazas-distribuidas","title":"13. Tempo (Trazas Distribuidas)","text":"<ul> <li>Est\u00e1ndar: OpenTelemetry.</li> <li>Justificaci\u00f3n: Permite visualizar la latencia en cada salto de una petici\u00f3n HTTP a trav\u00e9s de m\u00faltiples microservicios (Ingress -&gt; Frontend -&gt; API -&gt; DB).</li> </ul>"},{"location":"projects/ktsw/main/#capa-6-datos-y-persistencia","title":"Capa 6: Datos y Persistencia","text":"<p>El estado es la parte dif\u00edcil de Kubernetes. KTSW aborda esto frontalmente.</p>"},{"location":"projects/ktsw/main/#14-longhorn-block-storage","title":"14. Longhorn (Block Storage)","text":"<ul> <li>Arquitectura: Storage distribuido nativo de nube. Convierte el almacenamiento local de los nodos en un pool replicado y resiliente.</li> </ul>"},{"location":"projects/ktsw/main/#15-cloudnativepg-postgresql","title":"15. CloudNativePG (PostgreSQL)","text":"<ul> <li>Operador: Gestiona el ciclo de vida de la base de datos: failover autom\u00e1tico, backups a S3 (MinIO) y Point-in-Time Recovery (PITR).</li> </ul>"},{"location":"projects/ktsw/main/#16-nats-jetstream-messaging","title":"16. NATS JetStream (Messaging)","text":"<ul> <li>Uso: Bus de mensajes para comunicaci\u00f3n as\u00edncrona entre microservicios, reemplazando REST para operaciones internas de alto rendimiento.</li> </ul>"},{"location":"projects/ktsw/main/#5-aplicacion-de-referencia-distributed-task-processor","title":"5. Aplicaci\u00f3n de Referencia: \"Distributed Task Processor\"","text":"<p>Para validar la infraestructura, se desarrollar\u00e1 una aplicaci\u00f3n que ejercite todos los componentes.</p> <p>Componentes de la App:</p> <ol> <li>API Gateway (Go): Recibe requests, valida JWT (Keycloak), deposita trabajos en NATS.</li> <li>Worker Pool (Rust/Go): Escucha NATS, escala horizontalmente (HPA) basado en la profundidad de la cola, procesa datos y guarda en Postgres.</li> <li>Status Service (Node): Lee de Redis (Cach\u00e9) y Postgres para dar feedback al usuario v\u00eda WebSockets.</li> </ol>"},{"location":"projects/ktsw/main/#6-roadmap-de-implementacion","title":"6. Roadmap de Implementaci\u00f3n","text":""},{"location":"projects/ktsw/main/#fase-0-fundamentos-la-base-fisica","title":"Fase 0: Fundamentos (La Base F\u00edsica)","text":"<ul> <li>Configuraci\u00f3n de Proxmox y Networking f\u00edsico.</li> <li>Definici\u00f3n de VLANs y reglas de Firewall en pfSense.</li> <li>Bootstrap de cluster Kubernetes (k3s hard mode).</li> </ul>"},{"location":"projects/ktsw/main/#fase-1-conectividad-y-seguridad-la-red","title":"Fase 1: Conectividad y Seguridad (La Red)","text":"<ul> <li>Despliegue de Cilium y eliminaci\u00f3n de kube-proxy.</li> <li>Configuraci\u00f3n de MetalLB en modo BGP.</li> <li>Implementaci\u00f3n de Ingress Controller (Traefik) y Cert-Manager.</li> </ul>"},{"location":"projects/ktsw/main/#fase-2-control-y-gitops-el-cerebro","title":"Fase 2: Control y GitOps (El Cerebro)","text":"<ul> <li>Estructuraci\u00f3n del repositorio de GitOps.</li> <li>Bootstrap de FluxCD.</li> <li>Configuraci\u00f3n de encriptaci\u00f3n de secretos (SOPS).</li> <li>Definici\u00f3n de pol\u00edticas de admisi\u00f3n (Gatekeeper).</li> </ul>"},{"location":"projects/ktsw/main/#fase-3-observabilidad-los-ojos","title":"Fase 3: Observabilidad (Los Ojos)","text":"<ul> <li>Despliegue del stack LGTM (Loki, Grafana, Tempo, VictoriaMetrics).</li> <li>Instrumentaci\u00f3n b\u00e1sica de componentes del sistema.</li> <li>Creaci\u00f3n de Dashboards \"Golden Signals\".</li> </ul>"},{"location":"projects/ktsw/main/#fase-4-datos-y-plataforma-el-musculo","title":"Fase 4: Datos y Plataforma (El M\u00fasculo)","text":"<ul> <li>Estabilizaci\u00f3n de almacenamiento persistente (Longhorn).</li> <li>Despliegue de servicios de datos (Postgres, Redis, NATS).</li> <li>Configuraci\u00f3n de Registry privado (Harbor).</li> </ul>"},{"location":"projects/ktsw/main/#fase-5-aplicacion-y-pipelines-la-carga","title":"Fase 5: Aplicaci\u00f3n y Pipelines (La Carga)","text":"<ul> <li>Creaci\u00f3n de pipelines de CI en Tekton.</li> <li>Desarrollo y despliegue de la aplicaci\u00f3n \"Distributed Task Processor\".</li> <li>Implementaci\u00f3n de HPA (Horizontal Pod Autoscaling) basado en m\u00e9tricas custom.</li> </ul>"},{"location":"projects/ktsw/main/#fase-6-operaciones-dia-2-y-caos-la-prueba-de-fuego","title":"Fase 6: Operaciones D\u00eda 2 y Caos (La Prueba de Fuego)","text":"<ul> <li>Backup &amp; DR: Implementaci\u00f3n de Velero y pruebas de restauraci\u00f3n total.</li> <li>Chaos Engineering: Instalaci\u00f3n de Litmus Chaos.</li> <li>Experimento 1: Eliminar pod de base de datos master (validar failover).</li> <li>Experimento 2: Introducir latencia de red (validar timeouts y circuit breakers).</li> <li>Experimento 3: P\u00e9rdida completa de un nodo worker (validar reprogramaci\u00f3n de pods).</li> </ul>"}]}